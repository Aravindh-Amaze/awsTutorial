AWSTemplateFormatVersion: '2010-09-09'

Description: awsTutorial(Friend System part)
Parameters:
  ResourceNamePrefix:
    Description: Prefix of resource name
    Default: awstutorial
    Type: String
  CognitoUserPool:
    Description: Cognito User Pool id of the cognito user pool client which provide
      authentication for graphql api
    Type: String
  CognitoUserPoolArn:
    Description: Cognito User Pool id of the cognito user pool client which provide
      authentication for graphql api
    Type: String
  CognitoUserPoolClient:
    Description: Cognito User Pool client id of the cognito user pool client which
      provide authentication for graphql api
    Type: String
Resources:
  awsTutorialSearchUsersLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _SearchUsers_Lambda_Function_Role
      Description: Role for AWS Lambda Functions Cognito User Pool
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - edgelambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Join
            - ''
            - - !Ref ResourceNamePrefix
              - _SearchUsers_Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: SearchUsersPolicy
                Effect: Allow
                Action:
                  - cognito-idp:ListUsers
                Resource:
                  - !Ref CognitoUserPoolArn
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialSearchUsersLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _SearchUsers_Lambda
      Description: Lambda function Search Users for Cognito user pool
      Code:
        ZipFile: |
          import os
          import boto3
          def lambda_handler(event, context):
              if not event['hint']:
                return {
                  'users': []
                }
              UserPool = os.environ['User_Pool']
              cognito_idp = boto3.client('cognito-idp')
              request_parameters = {
                'UserPoolId': UserPool,
                'Limit': 20
              }
              try:
                if event['hint']:
                  filter_expression = f"username = '{event['hint']}'"
                  request_parameters['Filter'] = filter_expression
                response = cognito_idp.list_users(**request_parameters)
                users = [
                  {
                    'Username': user['Username'],
                    'Attributes': user['Attributes']
                  }
                  for user in response['Users']
                ]
                if len(users) > 0:
                  output = {
                    'users': users,
                  }
                  return output
                if event['hint']:
                  filter_expression = f"email = '{event['hint']}'"
                  request_parameters['Filter'] = filter_expression
                response = cognito_idp.list_users(**request_parameters)
                users = [
                  {
                    'Username': user['Username'],
                    'Attributes': user['Attributes']
                  }
                  for user in response['Users']
                ]
                if len(users) > 0:
                  output = {
                    'users': users,
                  }
                  return output
                if event['hint']:
                  filter_expression = f"preferred_username = '{event['hint']}'"
                  request_parameters['Filter'] = filter_expression
                response = cognito_idp.list_users(**request_parameters)
                users = [
                  {
                    'Username': user['Username'],
                    'Attributes': user['Attributes']
                  }
                  for user in response['Users']
                ]
                if len(users) > 0:
                  output = {
                    'users': users,
                  }
                  return output
                return {
                  'users': []
                }
              except Exception as e:
                raise Exception(f"Error processing request: {str(e)}")
      Environment:
        Variables:
          User_Pool: !Ref CognitoUserPool
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !GetAtt awsTutorialSearchUsersLambdaRole.Arn
      Runtime: python3.12
      Timeout: 30
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialGetUserLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _GetUser_Lambda_Function_Role
      Description: Role for AWS Lambda Functions Cognito User Pool
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - edgelambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Join
            - ''
            - - !Ref ResourceNamePrefix
              - _GetUser_Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: SearchUsersPolicy
                Effect: Allow
                Action:
                  - cognito-idp:AdminGetUser
                Resource:
                  - !Ref CognitoUserPoolArn
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialGetUserLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _GetUser_Lambda
      Description: Lambda function Get User for Cognito user pool
      Code:
        ZipFile: |
          import os
          import boto3
          def lambda_handler(event, context):
              UserPool = os.environ['User_Pool']
              cognito_idp = boto3.client('cognito-idp')
              request_parameters = {
                'UserPoolId': UserPool,
                'Username': event['username']
              }
              try:
                response = cognito_idp.admin_get_user(**request_parameters)
                output = {
                  'Username': response['Username'],
                  'UserAttributes': response['UserAttributes'],
                }
                return output
              except Exception as e:
                raise Exception(f"Error processing request: {str(e)}")
      Environment:
        Variables:
          User_Pool: !Ref CognitoUserPool
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !GetAtt awsTutorialGetUserLambdaRole.Arn
      Runtime: python3.12
      Timeout: 30
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialFriendListDynamoDBTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _FriendList_DynamoDB_Table
      AttributeDefinitions:
        - AttributeName: toUser
          AttributeType: S
        - AttributeName: fromUser
          AttributeType: S
        - AttributeName: friendStatus
          AttributeType: S
      BillingMode: PAY_PER_REQUEST
      DeletionProtectionEnabled: false
      OnDemandThroughput:
        MaxReadRequestUnits: 1
        MaxWriteRequestUnits: 1
      TableClass: STANDARD
      KeySchema:
        - AttributeName: toUser
          KeyType: HASH
        - AttributeName: fromUser
          KeyType: RANGE
      GlobalSecondaryIndexes:
        - IndexName: byFromUser
          KeySchema:
            - AttributeName: fromUser
              KeyType: HASH
            - AttributeName: friendStatus
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
          OnDemandThroughput:
            MaxReadRequestUnits: 1
            MaxWriteRequestUnits: 1
        - IndexName: byToUser
          KeySchema:
            - AttributeName: toUser
              KeyType: HASH
            - AttributeName: friendStatus
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
          OnDemandThroughput:
            MaxReadRequestUnits: 1
            MaxWriteRequestUnits: 1
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  # add DAX if you want but it will charge you per hours. Only add it when you are at the corner of releasing your game.
  awsTutorialFriendListLambdaFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _FriendList_Lambda_Function_Role
      Description: Role for AWS Lambda Functions Friend List Table
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - edgelambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Join
            - ''
            - - !Ref ResourceNamePrefix
              - _FriendList_Lambda_Function_Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: FriendListLambdaFunctionPolicy
                Effect: Allow
                Action:
                  - dynamodb:PartiQLSelect
                Resource:
                  - !GetAtt awsTutorialFriendListDynamoDBTable.Arn
                  - !Join
                    - ''
                    - - !GetAtt awsTutorialFriendListDynamoDBTable.Arn
                      - /*
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialGetFriendStatusLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _GetFriendStatus_Lambda
      Description: Lambda function List Pending Friend Requests for FriendList table
      Code:
        ZipFile: |
          import os
          import boto3
          def lambda_handler(event, context):
              friendListTableName = os.environ['TABLE_NAME']
              dynamodb = boto3.client('dynamodb')
              try:
                statement = 'select * from {0} where (toUser = ? and fromUser = ?)'.format(friendListTableName)
                request_parameters = {
                  'Statement': statement,
                  'Parameters': [{
                    "S": event['username'],
                  },{
                    "S": event['user'],
                  }],
                  'Limit': 20
                }
                response = dynamodb.execute_statement(**request_parameters)
                if response['Items']:
                  output = {
                    'toUser': response['Items'][0]['toUser']['S'],
                    'fromUser': response['Items'][0]['fromUser']['S'],
                    'friendStatus': response['Items'][0]['friendStatus'].get('S', 'none or rejected'),
                    'createdAt': int(response['Items'][0]['createdAt'].get('N', 0)),
                    'updatedAt': int(response['Items'][0]['updatedAt'].get('N', 0)),
                  }
                  return output
                statement = 'select * from {0} where (toUser = ? and fromUser = ?)'.format(friendListTableName)
                request_parameters = {
                  'Statement': statement,
                  'Parameters': [{
                    "S": event['user'],
                  },{
                    "S": event['username'],
                  }],
                  'Limit': 20
                }
                response = dynamodb.execute_statement(**request_parameters)
                if response['Items']:
                  output = {
                    'toUser': response['Items'][0]['toUser']['S'],
                    'fromUser': response['Items'][0]['fromUser']['S'],
                    'friendStatus': response['Items'][0]['friendStatus'].get('S', 'none or rejected'),
                    'createdAt': int(response['Items'][0]['createdAt'].get('N', 0)),
                    'updatedAt': int(response['Items'][0]['updatedAt'].get('N', 0)),
                  }
                  return output
                output = {
                  'toUser': event['user'],
                  'fromUser': event['username'],
                  'friendStatus': 'none or rejected',
                }
                return output
              except Exception as e:
                raise Exception(f"Error processing request: {str(e)}")
      Environment:
        Variables:
          TABLE_NAME: !Ref awsTutorialFriendListDynamoDBTable
      Handler: index.lambda_handler
      # LoggingConfig:
      #   LogFormat: Text
      MemorySize: 256
      Role: !GetAtt awsTutorialFriendListLambdaFunctionRole.Arn
      Runtime: python3.12
      Timeout: 30
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialListPendingFriendRequestsLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _ListPendingFriendRequests_Lambda
      Description: Lambda function List Pending Friend Requests for FriendList table
      Code:
        ZipFile: |
          import os
          import boto3
          def lambda_handler(event, context):
              friendListTableName = os.environ['TABLE_NAME']
              dynamodb = boto3.client('dynamodb')
              statement = 'select * from {0} where (toUser = ? or fromUser = ?) and friendStatus = \'sent\''.format(friendListTableName)
              request_parameters = {
                'Statement': statement,
                'Parameters': [{
                  "S": event['username'],
                }, {
                  "S": event['username'],
                }],
                'Limit': 20
              }
              if event['nextToken']:
                request_parameters['NextToken'] = event['nextToken']
              try:
                response = dynamodb.execute_statement(**request_parameters)
                output = {
                  'friends': [{
                    'toUser': user['toUser']['S'],
                    'fromUser': user['fromUser']['S'],
                    'friendStatus': user['friendStatus']['S'],
                    'createdAt': int(user['createdAt'].get('N', 0)),
                    'updatedAt': int(user['updatedAt'].get('N', 0)),
                  } for user in response['Items']],
                  'nextToken': response.get('NextToken', None),
                }
                return output
              except Exception as e:
                raise Exception(f"Error processing request: {str(e)}")
      Environment:
        Variables:
          TABLE_NAME: !Ref awsTutorialFriendListDynamoDBTable
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !GetAtt awsTutorialFriendListLambdaFunctionRole.Arn
      Runtime: python3.12
      Timeout: 30
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialListFriendsLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _ListFriends_Lambda
      Description: Lambda function List Friends for FriendList table
      Code:
        ZipFile: |
          import os
          import boto3
          def lambda_handler(event, context):
              friendListTableName = os.environ['TABLE_NAME']
              dynamodb = boto3.client('dynamodb')
              statement = 'select * from {0} where (toUser = ? or fromUser = ?) and friendStatus = \'accepted\''.format(friendListTableName)
              request_parameters = {
                'Statement': statement,
                'Parameters': [{
                  "S": event['username'],
                }, {
                  "S": event['username'],
                }],
                'Limit': 20
              }
              if event['nextToken']:
                request_parameters['NextToken'] = event['nextToken']
              try:
                response = dynamodb.execute_statement(**request_parameters)
                output = {
                  'friends': [{
                    'toUser': user['toUser']['S'],
                    'fromUser': user['fromUser']['S'],
                    'friendStatus': user['friendStatus']['S'],
                    'createdAt': int(user['createdAt'].get('N', 0)),
                    'updatedAt': int(user['updatedAt'].get('N', 0)),
                  } for user in response['Items']],
                  'nextToken': response.get('NextToken', None),
                }
                return output
              except Exception as e:
                raise Exception(f"Error processing request: {str(e)}")
      Environment:
        Variables:
          TABLE_NAME: !Ref awsTutorialFriendListDynamoDBTable
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !GetAtt awsTutorialFriendListLambdaFunctionRole.Arn
      Runtime: python3.12
      Timeout: 30
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialGraphQLApi:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _GraphQL_API
      ApiType: GRAPHQL
      AuthenticationType: AMAZON_COGNITO_USER_POOLS
      IntrospectionConfig: ENABLED
      UserPoolConfig:
        AppIdClientRegex: !Ref CognitoUserPoolClient
        AwsRegion: !Ref AWS::Region
        DefaultAction: ALLOW
        UserPoolId: !Ref CognitoUserPool
      Tags:
        - Key: Usage
          Value: Youtube Streamer
      Visibility: GLOBAL
  awsTutorialSearchUsersLambdaFunctionDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _SearchUsers_DataSource_Role
      Description: Role for AWS Graphql Api Search Users Data Source
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Join
            - ''
            - - !Ref ResourceNamePrefix
              - _SearchUsers_DataSource_Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: SearchUsersDataSourcePolicy
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt awsTutorialSearchUsersLambdaFunction.Arn
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialGetUserLambdaFunctionDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _GetUser_DataSource_Role
      Description: Role for AWS Graphql Api Get User Data Source
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Join
            - ''
            - - !Ref ResourceNamePrefix
              - _GetUser_DataSource_Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: GetUserDataSourcePolicy
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt awsTutorialGetUserLambdaFunction.Arn
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialGetFriendStatusLambdaFunctionDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _GetFriendStatus_DataSource_Role
      Description: Role for AWS Graphql Api Get Friend Status Data Source
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Join
            - ''
            - - !Ref ResourceNamePrefix
              - _GetFriendStatus_DataSource_Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: GetFriendStatusDataSourcePolicy
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt awsTutorialGetFriendStatusLambdaFunction.Arn
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialListPendingFriendRequestsLambdaFunctionDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _ListPendingFriendRequests_DataSource_Role
      Description: Role for AWS Graphql Api List Pending Friend Requests Data Source
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Join
            - ''
            - - !Ref ResourceNamePrefix
              - _ListPendingFriendRequests_DataSource_Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: ListPendingFriendRequestsDataSourcePolicy
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt awsTutorialListPendingFriendRequestsLambdaFunction.Arn
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialListFriendsLambdaFunctionDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _ListFriends_DataSource_Role
      Description: Role for AWS Graphql Api List Friends Data Source
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Join
            - ''
            - - !Ref ResourceNamePrefix
              - _ListFriends_DataSource_Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: ListFriendsDataSourcePolicy
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt awsTutorialListFriendsLambdaFunction.Arn
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialFriendListDataSourceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _FriendList_DataSource_Role
      Description: Role for AWS Graphql Api Friend List Data Source
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Join
            - ''
            - - !Ref ResourceNamePrefix
              - _FriendList_DataSource_Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: FriendListDataSourcePolicy
                Effect: Allow
                Action:
                  - dynamodb:DeleteItem
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt awsTutorialFriendListDynamoDBTable.Arn
                  - !Join
                    - ''
                    - - !GetAtt awsTutorialFriendListDynamoDBTable.Arn
                      - /*
      Tags:
        - Key: Usage
          Value: Youtube Streamer
  awsTutorialSearchUsersDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _SearchUsers_DataSource
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      Description: Connect graphql api with search users function
      LambdaConfig:
        LambdaFunctionArn: !GetAtt awsTutorialSearchUsersLambdaFunction.Arn
      ServiceRoleArn: !GetAtt awsTutorialSearchUsersLambdaFunctionDataSourceRole.Arn
      Type: AWS_LAMBDA
  awsTutorialGetUserDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _GetUser_DataSource
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      Description: Connect graphql api with Get user function
      LambdaConfig:
        LambdaFunctionArn: !GetAtt awsTutorialGetUserLambdaFunction.Arn
      ServiceRoleArn: !GetAtt awsTutorialGetUserLambdaFunctionDataSourceRole.Arn
      Type: AWS_LAMBDA
  awsTutorialGetFriendStatusDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _GetFriendStatus_DataSource
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      Description: Connect graphql api with get friend status function
      LambdaConfig:
        LambdaFunctionArn: !GetAtt awsTutorialGetFriendStatusLambdaFunction.Arn
      ServiceRoleArn: !GetAtt awsTutorialGetFriendStatusLambdaFunctionDataSourceRole.Arn
      Type: AWS_LAMBDA
  awsTutorialListPendingFriendRequestsDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _ListPendingFriendRequests_DataSource
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      Description: Connect graphql api with list pending friend requests function
      LambdaConfig:
        LambdaFunctionArn: !GetAtt awsTutorialListPendingFriendRequestsLambdaFunction.Arn
      ServiceRoleArn: !GetAtt awsTutorialListPendingFriendRequestsLambdaFunctionDataSourceRole.Arn
      Type: AWS_LAMBDA
  awsTutorialListFriendsDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _ListFriends_DataSource
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      Description: Connect graphql api with list friends function
      LambdaConfig:
        LambdaFunctionArn: !GetAtt awsTutorialListFriendsLambdaFunction.Arn
      ServiceRoleArn: !GetAtt awsTutorialListFriendsLambdaFunctionDataSourceRole.Arn
      Type: AWS_LAMBDA
  awsTutorialFriendListDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _FriendList_DataSource
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      Description: Connect graphql api with Friend List data table
      DynamoDBConfig:
        AwsRegion: !Ref AWS::Region
        TableName: !Ref awsTutorialFriendListDynamoDBTable
      ServiceRoleArn: !GetAtt awsTutorialFriendListDataSourceRole.Arn
      Type: AMAZON_DYNAMODB
  awsTutorialNoneDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _None_DataSource
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      Description: Data source for subscriptions
      Type: NONE
  awsTutorialGraphQLSchema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      Definition: |
        schema @aws_cognito_user_pools {
          query: Query
          mutation: Mutation
          subscription: Subscription
        }
        type UserAttribute @aws_cognito_user_pools {
          Name: String!
          Value: String
        }
        type GetUserResult @aws_cognito_user_pools {
          Username: String!
          UserAttributes: [UserAttribute]!
        }
        type Friend @aws_cognito_user_pools {
          fromUser: String!
          toUser: String!
          friendStatus: String!
          createdAt: Int
          updatedAt: Int
        }
        type ListFriendsResult @aws_cognito_user_pools {
          friends: [Friend]
          nextToken: String
        }
        type Query @aws_cognito_user_pools {
          listPendingFriendRequests(nextToken: String): ListFriendsResult
          listFriends(nextToken: String): ListFriendsResult
          getUser(username: String!): GetUserResult
        }
        type Mutation @aws_cognito_user_pools {
          sendFriendRequest(toUser: String!): Friend
          acceptFriendRequest(fromUser: String!): Friend
          rejectFriendRequest(fromUser: String!): Friend
          deleteFriend(toUser: String!): Friend
        }
        type Subscription @aws_cognito_user_pools {
          friendRequestSent: Friend @aws_subscribe(mutations: ["sendFriendRequest"])
          friendRequestAccepted(toUser: String): Friend @aws_subscribe(mutations: ["acceptFriendRequest"])
          friendRequestRejected(toUser: String): Friend @aws_subscribe(mutations: ["rejectFriendRequest"])
          friendRequestDeleted(toUser: String): Friend @aws_subscribe(mutations: ["deleteFriend"])
        }
  awsTutorialGraphQLQueryGetUserRequestsResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialGetUserDataSource.Name
      FieldName: getUser
      Kind: UNIT
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        ## [End] Check authMode and execute owner/group checks **
        {
          "version": "2017-02-28",
          "operation": "Invoke",
          "payload": {
            "username": "${ctx.args.username}"
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $utils.toJson($ctx.result)
        #end
      TypeName: Query
  awsTutorialGraphQLQueryListPendingFriendRequestsResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialListPendingFriendRequestsDataSource.Name
      FieldName: listPendingFriendRequests
      Kind: UNIT
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        ## [End] Check authMode and execute owner/group checks **
        {
          "version": "2017-02-28",
          "operation": "Invoke",
          "payload": {
            "username": "${identityValue}",
            "nextToken": "${ctx.args.nextToken}"
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $utils.toJson($ctx.result)
        #end
      TypeName: Query
  awsTutorialGraphQLQueryListFriendsResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialListFriendsDataSource.Name
      FieldName: listFriends
      Kind: UNIT
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        ## [End] Check authMode and execute owner/group checks **
        {
          "version": "2017-02-28",
          "operation": "Invoke",
          "payload": {
            "username": "${identityValue}",
            "nextToken": "${ctx.args.nextToken}"
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $utils.toJson($ctx.result)
        #end
      TypeName: Query
  awsTutorialGraphQLMutationSearchUserFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _Search_User_Function
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialSearchUsersDataSource.Name
      Description: Search user
      FunctionVersion: '2018-05-29'
      RequestMappingTemplate: |
        {
          "version": "2017-02-28",
          "operation": "Invoke",
          "payload": {
            "hint": "$ctx.args.toUser",
            "nextToken": ""
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          #set($result = { "count": 0 })
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          #if($util.isNull($ctx.result.users))
            #set($result = { "count": 0 })
            $util.error("can't get previous result. please contact dev. ", "InternalError")
          #else
            #if( $ctx.result.users.size() == 0 )
              $util.error("Hm, didn't work. Please double check the username is correct. ", "NotExists")
            #end
            #if( $ctx.result.users.size() > 1 )
              $util.error("more than one username found with ${ctx.args.toUser}, please contact dev. ", "InternalError")
            #end
            #set($ctx.stash.user = $ctx.result.users[0])
            #set($result = {
              "count": $ctx.result.users.size(),
              "users": $ctx.result.users,
              "nextToken": $ctx.result.nextToken
            })
          #end
        #end
        $util.toJson($result)
  awsTutorialGraphQLMutationGetFriendStatusFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _GetFriendStatus_Function
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialGetFriendStatusDataSource.Name
      Description: Get Friend Status
      FunctionVersion: '2018-05-29'
      RequestMappingTemplate: |
        #if( $util.isNull($ctx.stash.user) )
          $util.error("not user requested. ", "InternalError")
        #end
        {
          "version": "2017-02-28",
          "operation": "Invoke",
          "payload": {
            "username": "$ctx.stash.identityValue",
            "user": "$ctx.stash.user.Username"
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          #set($result = { "friendStatus": 'none or rejected' })
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          #set($result = $ctx.result)
        #end
        $util.toJson($result)
  awsTutorialGraphQLMutationCreateFriendRequestFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _Create_Friend_Function
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialFriendListDataSource.Name
      Description: Create friend request
      FunctionVersion: '2018-05-29'
      RequestMappingTemplate: |
        #if( $ctx.prev.result.friendStatus == 'accepted' )
          $util.error("You're already friends with that user. ", "AlreadyExists")
        #end
        #if( $ctx.prev.result.friendStatus == 'sent' )
          $util.error("You or that user have already sent friend request. ", "AlreadyExists")
        #end
        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": {
            "toUser": $util.dynamodb.toDynamoDBJson($ctx.stash.user['Username']),
            "fromUser": $util.dynamodb.toDynamoDBJson($ctx.stash.identityValue)
          },
          "attributeValues": {
            "friendStatus": $util.dynamodb.toDynamoDBJson("sent"),
            "createdAt": $util.dynamodb.toDynamoDBJson($ctx.args.createdAt),
            "updatedAt": $util.dynamodb.toDynamoDBJson($ctx.args.updatedAt)
          },
          "condition": {
            "expression": "attribute_not_exists(toUser) OR attribute_not_exists(fromUser)",
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $utils.toJson($ctx.result)
        #end
  awsTutorialGraphQLMutationSendFriendRequestResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      FieldName: sendFriendRequest
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt awsTutorialGraphQLMutationSearchUserFunction.FunctionId
          - !GetAtt awsTutorialGraphQLMutationGetFriendStatusFunction.FunctionId
          - !GetAtt awsTutorialGraphQLMutationCreateFriendRequestFunction.FunctionId
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        #set( $createdAt = $util.time.nowEpochSeconds() )
        #set( $updatedAt = $util.time.nowEpochSeconds() )
        ## Automatically set the createdAt timestamp. **
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            $util.qr($ctx.args.put("player", "${identityValue}"))
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        #set($ctx.stash.identityValue = $identityValue)
        ## [End] Check authMode and execute owner/group checks **
        #if( $identityValue == $ctx.args.toUser )
          $util.error("You are sending friend request to yourself", "InvalidParameter")
        #end
        $util.qr($ctx.args.put("createdAt", $createdAt))
        $util.qr($ctx.args.put("updatedAt", $updatedAt))
        {}
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $util.toJson($ctx.prev.result)
        #end
      TypeName: Mutation
  awsTutorialGraphQLMutationAcceptFriendRequestResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialFriendListDataSource.Name
      FieldName: acceptFriendRequest
      Kind: UNIT
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        #set( $updatedAt = $util.time.nowEpochSeconds() )
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        ## [End] Check authMode and execute owner/group checks **
        #if( $identityValue == $ctx.args.fromUser )
          $util.error("You are accepting a friend request to yourself", "InvalidParameter")
        #end
        ## @TODO: make sure the friend request exists and the status is sent.
        {
          "version": "2017-02-28",
          "operation": "UpdateItem",
          "key": {
            "toUser": $util.dynamodb.toDynamoDBJson($identityValue),
            "fromUser": $util.dynamodb.toDynamoDBJson($ctx.args.fromUser)
          },
          "update": {
            "expression": "SET #friendStatus = :friendStatus, #updatedAt = :updatedAt",
            "expressionNames": {
              "#friendStatus": "friendStatus",
              "#updatedAt": "updatedAt"
            },
            "expressionValues": {
              ":friendStatus": $util.dynamodb.toDynamoDBJson("accepted"),
              ":updatedAt": $util.dynamodb.toDynamoDBJson($updatedAt)
            }
          },
          "condition": {
            "expression": "attribute_exists(toUser) AND attribute_exists(fromUser)"
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $utils.toJson($ctx.result)
        #end
      TypeName: Mutation
  awsTutorialGraphQLMutationRejectFriendRequestResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialFriendListDataSource.Name
      FieldName: rejectFriendRequest
      Kind: UNIT
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        #set( $updatedAt = $util.time.nowEpochSeconds() )
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        ## [End] Check authMode and execute owner/group checks **
        #if( $identityValue == $ctx.args.fromUser )
          $util.error("You are rejecting a friend request to yourself", "InvalidParameter")
        #end
        ## @TODO: make sure the friend request exists and the status is sent.
        {
          "version": "2017-02-28",
          "operation": "DeleteItem",
          "key": {
            "toUser": $util.dynamodb.toDynamoDBJson($identityValue),
            "fromUser": $util.dynamodb.toDynamoDBJson($ctx.args.fromUser)
          },
          "condition": {
            "expression": "attribute_exists(toUser) AND attribute_exists(fromUser)"
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $utils.toJson($ctx.result)
        #end
      TypeName: Mutation
  awsTutorialGraphQLMutationDeleteFriendRequestFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
      Name: !Join
        - ''
        - - !Ref ResourceNamePrefix
          - _Delete_Friend_Function
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialFriendListDataSource.Name
      Description: Delete friend request
      FunctionVersion: '2018-05-29'
      RequestMappingTemplate: |
        #if( $ctx.prev.result.friendStatus == 'none or rejected' )
          $util.error("You're not a friend or pending friend with that user. ", "NotExists")
        #end
        {
          "version": "2017-02-28",
          "operation": "DeleteItem",
          "key": {
            "toUser": $util.dynamodb.toDynamoDBJson($ctx.prev.result.toUser),
            "fromUser": $util.dynamodb.toDynamoDBJson($ctx.prev.result.fromUser)
          },
          "condition": {
            "expression": "attribute_exists(toUser) OR attribute_exists(fromUser)",
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $utils.toJson($ctx.result)
        #end
  awsTutorialGraphQLMutationDeleteFriendRequestResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      FieldName: deleteFriend
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt awsTutorialGraphQLMutationGetFriendStatusFunction.FunctionId
          - !GetAtt awsTutorialGraphQLMutationDeleteFriendRequestFunction.FunctionId
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        #set( $createdAt = $util.time.nowEpochSeconds() )
        #set( $updatedAt = $util.time.nowEpochSeconds() )
        ## Automatically set the createdAt timestamp. **
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            $util.qr($ctx.args.put("player", "${identityValue}"))
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        #set($ctx.stash.identityValue = $identityValue)
        ## [End] Check authMode and execute owner/group checks **
        #if( $identityValue == $ctx.args.toUser )
          $util.error("You are deleting a friend request to yourself", "InvalidParameter")
        #end
        $util.qr($ctx.args.put("createdAt", $createdAt))
        $util.qr($ctx.args.put("updatedAt", $updatedAt))
        #set($ctx.stash.user = {
          "Username": $ctx.args.toUser
        })
        {}
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $util.toJson($ctx.prev.result)
        #end
      TypeName: Mutation
  awsTutorialGraphQLSubscriptionFriendRequestSentResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialNoneDataSource.Name
      FieldName: friendRequestSent
      Kind: UNIT
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        #set( $updatedAt = $util.time.nowEpochSeconds() )
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        #set($ctx.stash.identityValue = $identityValue)
        ## [End] Check authMode and execute owner/group checks **
        ## @TODO: make sure the friend request exists and the status is sent.
        {
          "version": "2018-05-29",
          "payload": null
        }
      ResponseMappingTemplate: |
        $extensions.setSubscriptionFilter({
          "filterGroup": [
            {
              "filters": [
                {
                  "fieldName": "toUser",
                  "operator": "eq",
                  "value": "${ctx.stash.identityValue}"
                }
              ]
            },
            {
              "filters": [
                {
                  "fieldName": "fromUser",
                  "operator": "eq",
                  "value": "${ctx.stash.identityValue}"
                }
              ]
            }
          ]
        })
        $util.toJson($ctx.result)
      TypeName: Subscription
  awsTutorialGraphQLSubscriptionFriendRequestAcceptedResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialNoneDataSource.Name
      FieldName: friendRequestAccepted
      Kind: UNIT
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        #set( $updatedAt = $util.time.nowEpochSeconds() )
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        #set($ctx.stash.identityValue = $identityValue)
        ## [End] Check authMode and execute owner/group checks **
        ## @TODO: make sure the friend request exists and the status is sent.
        {
          "version": "2018-05-29",
          "payload": null
        }
      ResponseMappingTemplate: |
        $extensions.setSubscriptionFilter({
          "filterGroup": [
            {
              "filters": [
                {
                  "fieldName": "fromUser",
                  "operator": "eq",
                  "value": "${ctx.stash.identityValue}"
                },{
                  "fieldName": "toUser",
                  "operator": "eq",
                  "value": "${ctx.args.toUser}"
                }
              ]
            },
            {
              "filters": [
                {
                  "fieldName": "toUser",
                  "operator": "eq",
                  "value": "${ctx.stash.identityValue}"
                },{
                  "fieldName": "fromUser",
                  "operator": "eq",
                  "value": "${ctx.args.toUser}"
                }
              ]
            }
          ]
        })
        $util.toJson($ctx.result)
      TypeName: Subscription
  awsTutorialGraphQLSubscriptionFriendRequestRejectedResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialNoneDataSource.Name
      FieldName: friendRequestRejected
      Kind: UNIT
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        #set( $updatedAt = $util.time.nowEpochSeconds() )
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        #set($ctx.stash.identityValue = $identityValue)
        ## [End] Check authMode and execute owner/group checks **
        ## @TODO: make sure the friend request exists and the status is sent.
        {
          "version": "2018-05-29",
          "payload": null
        }
      ResponseMappingTemplate: |
        $extensions.setSubscriptionFilter({
          "filterGroup": [
            {
              "filters": [
                {
                  "fieldName": "fromUser",
                  "operator": "eq",
                  "value": "${ctx.stash.identityValue}"
                },{
                  "fieldName": "toUser",
                  "operator": "eq",
                  "value": "${ctx.args.toUser}"
                }
              ]
            },
            {
              "filters": [
                {
                  "fieldName": "toUser",
                  "operator": "eq",
                  "value": "${ctx.stash.identityValue}"
                },{
                  "fieldName": "fromUser",
                  "operator": "eq",
                  "value": "${ctx.args.toUser}"
                }
              ]
            }
          ]
        })
        $util.toJson($ctx.result)
      TypeName: Subscription
  awsTutorialGraphQLSubscriptionFriendRequestDeletedResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt awsTutorialGraphQLApi.ApiId
      DataSourceName: !GetAtt awsTutorialNoneDataSource.Name
      FieldName: friendRequestDeleted
      Kind: UNIT
      RequestMappingTemplate: |
        ## [Start] Set default values. **
        #set( $updatedAt = $util.time.nowEpochSeconds() )
        ## [End] Set default values. **
        ## [Start] Determine request authentication mode **
        #if( $util.isNullOrEmpty($authMode) && !$util.isNull($ctx.identity) && !$util.isNull($ctx.identity.sub) && !$util.isNull($ctx.identity.issuer) && !$util.isNull($ctx.identity.username) && !$util.isNull($ctx.identity.claims) && !$util.isNull($ctx.identity.sourceIp) && !$util.isNull($ctx.identity.defaultAuthStrategy) )
          #set( $authMode = "userPools" )
        #end
        ## [End] Determine request authentication mode **
        ## [Start] Check authMode and execute owner/group checks **
        #if( $authMode == "userPools" )
          ## No Static Group Authorization Rules **
          ## No Dynamic Group Authorization Rules **
          ## [Start] Owner Authorization Checks **
          #set( $isOwnerAuthorized = false )
          ## Authorization rule: { allow: owner, ownerField: "player", identityClaim: "cognito:username" } **
          #set( $allowedOwners0 = $util.defaultIfNull($ctx.args.player, null) )
          #set( $identityValue = $util.defaultIfNull($ctx.identity.claims.get("username"), $util.defaultIfNull($ctx.identity.claims.get("cognito:username"), "___xamznone____")) )
          #if( $util.isString($allowedOwners0) )
            #if( $allowedOwners0 == $identityValue )
              #set( $isOwnerAuthorized = true )
            #end
          #end
          #if( $util.isNull($allowedOwners0) && (! $ctx.args.containsKey("player")) )
            #set( $isOwnerAuthorized = true )
          #end
          ## [End] Owner Authorization Checks **
          ## [Start] Throw if unauthorized **
          #if( !($isStaticGroupAuthorized == true || $isDynamicGroupAuthorized == true || $isOwnerAuthorized == true) )
            $util.unauthorized()
          #end
          ## [End] Throw if unauthorized **
        #else
          $util.unauthorized()
        #end
        #set($ctx.stash.identityValue = $identityValue)
        ## [End] Check authMode and execute owner/group checks **
        ## @TODO: make sure the friend request exists and the status is sent.
        {
          "version": "2018-05-29",
          "payload": null
        }
      ResponseMappingTemplate: |
        $extensions.setSubscriptionFilter({
          "filterGroup": [
            {
              "filters": [
                {
                  "fieldName": "toUser",
                  "operator": "eq",
                  "value": "${ctx.stash.identityValue}"
                },
                {
                  "fieldName": "fromUser",
                  "operator": "eq",
                  "value": "${ctx.args.toUser}"
                }
              ]
            },{
              "filters": [
                {
                  "fieldName": "toUser",
                  "operator": "eq",
                  "value": "${ctx.args.toUser}"
                },
                {
                  "fieldName": "fromUser",
                  "operator": "eq",
                  "value": "${ctx.stash.identityValue}"
                }
              ]
            }
          ]
        })
        $util.toJson($ctx.result)
      TypeName: Subscription
Outputs:
  awsTutorialRegion:
    Description: AWS Region
    Value: !Ref AWS::Region
    Export:
      Name: !Sub 'awsTutorialRegion'
  awsTutorialGraphQLHost:
    Description: GraphQL Host
    Value: !GetAtt awsTutorialGraphQLApi.GraphQLDns
    Export:
      Name: !Sub 'awsTutorialGraphQLHost'
  awsTutorialGraphQLEndpoint:
    Description: GraphQL Endpoint
    Value: !GetAtt awsTutorialGraphQLApi.GraphQLUrl
    Export:
      Name: !Sub 'awsTutorialGraphQLEndpoint'
  awsTutorialGraphQLRealtimeEndpoint:
    Description: GraphQL realtime Endpoint
    Value: !GetAtt awsTutorialGraphQLApi.RealtimeUrl
    Export:
      Name: !Sub 'awsTutorialGraphQLRealtimeEndpoint'
Metadata:
  AWS::Composer::Groups:
    Group:
      Label: Friend System
      Members:
        - awsTutorialGraphQLApi
        - awsTutorialGraphQLMutationSearchUserFunction
        - awsTutorialGraphQLMutationGetFriendStatusFunction
        - awsTutorialGraphQLMutationDeleteFriendRequestFunction
        - awsTutorialGraphQLMutationCreateFriendRequestFunction
        - awsTutorialGetUserLambdaRole
        - awsTutorialSearchUsersLambdaRole
        - awsTutorialFriendListLambdaFunctionRole
        - awsTutorialFriendListDynamoDBTable
        - awsTutorialListPendingFriendRequestsLambdaFunction
        - awsTutorialListFriendsLambdaFunction